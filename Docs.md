# Architecture
## Loading games
 SGE dynamically loads one selected game (in code named mod) from the "mods" folder.
 Mods must met some requirements, eg. contains all the config files. (See *TODO*)
 Once the mod is loaded, SGE loads a scene gived in mod/manifest.json in "start_scene" field. 
 
## Entities, components and assets
 In SGE, game objects are called **entities**. Entities are composites made of **components**.
 Components allows entities to interact with engine subsystems, for instance colliders affects the collision system.
 Components can be also added and removed from the entities at runtime. 

 Often components needs additional data to work, eg. sprite needs an image.
 This data is stored inside **assets**. Assets are automatically loaded when needed, and unloaded when not.

## Components in detail
 Each components has its own unique name (a 32 bit usingned integer), that differentiate it from other components inside the entity.
 Engine lua api allows passing strings as the components names - passed strings will be auto hashed into integers.

 There are 10 types of components:
 
 -*behavior* : links *behavior asset* to the entity therefore adding logic to the owner  
 -*camera* : allows renderer to render game objects to the screen  
 -*collider* : adds collision to the entity  
 -*dynamics* : handles forces, gravitation etc.  
 -*static mesh* : remders given *mesh asset* with given *shader asset* and given set of *texture assets*  
 -*sprite* : renders sprite + adds collision  
 -*flipbook* : renders flipbook (animations made of sprites) + adds collision  
 -*tilemap* : renders *tilemap asset* using textures from *tileset asset* + adds collision   
 -*sound emitter* : emitts *sound asset* in owner's position  
 -*listener* : represents sound listener in world space  

 ## Assets in detail
  Each asset is represented by .json file, consisting of "asset_type" field, with string determining asset type, and additional asset-type-dependant data.  
  Example sprite_sheet asset:  
  ```json
  {
      "asset_type" : "sprite_sheet",
      "path" : "$/player_sprite_sheet.png",
  
      "sprite_width" : 16,
      "sprite_height" : 16
  }
```
  There are 14 types of assets:  
  
-*behavior* : represents lua script. (See *TODO*) Example:  
 ```json
{
    "asset_type" : "behavior",
    "path" : "$/controller.lua"
}
```
-*texture* : represents texture. (See *TODO*) Example:
```json
{
    "asset_type" : "texture",
    "path" : "$/apple_texture.png",
}
```
-*sprite_sheet* : represents sprite sheet. (See *TODO*) Example:
```json
{
    "asset_type" : "flipbook",
    "path" : "$/player_sprite_sheet.png",

    "sprite_width" : 16,
    "sprite_height" : 16
}
```
-*flipbook* : represents sprite sheet, and provide information about animations. (See *TODO*) Example:
```json
{
    "asset_type" : "flipbook",
    "path" : "$/player_sprite_sheet.png",

    "sprite_width" : 16,
    "sprite_height" : 16,

    "animations" : {
        "idle" : {
            "fps" : 4,
            "frames" : [0, 1, 2, 3, 4, 5]
        }
    }
}
```
-*shader* : represents GLSL shader. (See *TODO*) Example:
```json
{
    "asset_type" : "shader",
    "path" : "$/sprite_shader.glsl"
}
```
-*tileset* : represents tileset and provide infromation about which tiles (Numbering from top-left corner, starting at 1) should have collision. (See *TODO*) Example:
```json
{
    "asset_type" : "tileset",
    "path" : "$/tileset.png",

    "tile_width" : 8,
    "tile_height" : 8,

    "collisions" : [
        1,  2,  3,  4,
        17, 19, 20,
        33, 34, 35, 36,
        49, 50, 51, 52,
    ]
}
```
-*tilemap* : represents tilemap generated by tiled program. (See *TODO*) Example:
```json
{
    "asset_type" : "tilemap",
    "path" : "$/tilemap.tmj"
}
```
-*scene* : represents lua script that create, and manage an scene. (See *TODO*) Example:
```json
{
    "asset_type" : "scene",
    "path" : "$/scene.lua"
}
```
-*sound* : represents mp3 sound. (See *TODO*) Example:
```json
{
    "asset_type" : "sound",
    "path" : "$/orchestra.mp3"
}
```
-*mesh* : represents an mesh (geometry). (See *TODO*) Example: 
```json
{
    "asset_type" : "mesh",
    "path" : "$/square_mesh.mesh"
}
```
-*rendering_config* : contains renderer configuration. (See *TODO*) Example:
```json
{
    "asset_type" : "rendering_config",
    "default_sprite_shader_override" : "core/sprite_shader",
    "use_pixel_aligned_camera" : true,
    "background_color" : [
        0.09411764705, 
        0.07843137254, 
        0.14509803921
    ]
}
```
-*input_config* : contains input subsystem configuraion. (See *TODO*) Example:
```json
{
    "asset_type" : "input_config",

    "action_mappings" : {
        "jump" : ["Space"],
        "attack" : ["Enter"]
    },

    "axis_mappings" : {
        "move_forward" : {
            "W" : 1,
            "S" : -1
        },
        "move_right" : {
            "D" : 1,
            "A" : -1
        }
    }
}
``` 
-*collision_config* : contains collision presets configuration (See *TODO*) Example:
```json
{
    "asset_type" : "collision_config",
  
    "body_types" : {
        "wall" : 0,
        "player" : 1,
        "enemy" : 2
    },
  
    "collision_presets" : {
        "player" : {
            "body_type" : "player",
            "responses" : {
               "player" : "ignore",
               "enemy" : "overlap",
               "wall" : "collide"
            }
        }
    }
}
```
-*custom_data* : contains custom set of informations. The information can be accessed from lua via _en_load_custom_data function. Example:
```json
{
    "asset_type" : "custom_data",

    "abc" : "foo",
    "b" : 64,
    "pi" : 3.14,
    "is_valid" : true,

    "an_object" : {
        "title" : "bar",
        "value" : 2024,
        "nested_data" : {
            "x" : 12
        }
    },
    "an_array" : [1, 2, 3],
    "array_of_objects" : [
        {
            "x" : 12
        },
        {
            "x" : 12
        }
    ]
}
```
# Engine API
SGE exposes api, through which lua scripts can manipulate the engine.  
All api functions uses following naming convention:   
``'\_' + letter indication of manipulated submodule / indication of the function + '\_' + rest of the name``
For example: ``_a_set_volume``, means ``audio\_subsystem::set\_volume``

Engine functions may also return some custom types:  
``entity`` is a lua wraper for std::weak_ptr<entities::entity>.   
``render_config`` is actually a specialised table that represents C++ rendering::render_config struct. It must contains:
```yaml
{
    string shader : a shader asset to use
    string mesh   : a mesh asset to render
    table textures : a set of texture / sprtie_sheet / tilemap / flipbook assets that will be passed to the gpu when drawing (optional)
    { 
        <any key> : string,
        <any other key> : string,
    }
}
```

## Entities Functions
Entities functions uses _e prefix.  

```lua 
entity_ref      _e_create()                                             --creates entity inside current scene (See *TODO*) and returns reference to it.
nil             _e_kill(entity_ref e)                                   --kills entity *e*    
nil             _e_is_alive(entity_ref e)                               --checks if entity *e* is still alive (has not been killed)

table           _e_call(entity_ref e, string event_name, table args)    --calls event of given name on all behaviors components inside the entity. Returns table of event calls return values. (See *TODO*)

nil             _e_teleport(entity_ref e, number x, number y)           --moves entity *e* to the postion *(x, y)* without checking the collision.  
bool            _e_sweep(entity_ref e, number x, number y)              --moves entity *e* to the position *(x, y)* while checking the collision. Returns true, if entity has collided with other entity.

number, number  _e_get_location(entity_ref e)                           --returns (x, y) position of the *e* entity
integer         _e_get_layer(entity_ref e)                              --returns layer on which the entity is located  
nil             _e_set_layer(entity_ref e, integer new_layer)           --sets layer on which the entity is located

nil             _e_kill_component(entity_ref e, integer | string name)  --removes compononent of the given name from the entity.  
```

## Add Component Function
Add component functions uses _e_add prefix.  

```lua
nil             _e_add_behavior(entity_ref e, integer | string name, string behavior_asset)                                                               --adds behavior component to the entity.  
nil             _e_add_camera(entity_ref e, integer | string name, number ortho_width)                                                                    --adds camera component with given ortho width.  
nil             _e_add_static_mesh(entity_ref e, integer | string name, render_config rc)                                                                 --adds static_mesh component to the entity.  
nil             _e_add_collider(entity_ref e, integer | string name, number extend_x, number extend_y)                                                    --adds collider component with given extend to the entity.  
nil             _e_add_sprite(entity_ref e, integer | string name, string sprite_sheet_asset, integer sprite_id, string collision_preset_name)            --adds sprite component to the entity.  
nil             _e_add_flipbook(entity_ref e, integer | string name, string sprite_sheet_asset, string flipbook_animation, string collision_preset_name)  --adds flipbook component to the entity.  
nil             _e_add_tilemap(entity_ref e, integer | string name, string tilemap_asset, string tileset_asset, string collision_preset_name)             --adds tilemap component to the entity.  
nil             _e_add_dynamics(entity_ref e, integer | string name)                                                                                      --adds dynamics component to the entity.   
nil             _e_add_listener(entity_ref e, integer | string name)                                                                                      --adds listener component to the entity.  
nil             _e_add_sound_emitter(entity_ref e, integer | string name)                                                                                 --adds sound emmiter component to the entity.
```

## Components Functions
Components functions uses _c\_ +  max. 2 letters indicating targetet component type prefix.  
Many functions are just obvious getters and setters so they descriptions are omitted.  
Also, because each of the functions takes as the first two arguments ``entity_ref e, integer/string component_name`` to shorten and simplify the docs those args are represented by \[Comp] in functions decriptions.  

any mesh component (static_mesh, sprite, flipbook, tilemap) functions (_c_m):  

```lua
bool            _c_m_get_visible([Comp])  
nil             _c_m_set_visible([Comp], bool visible)

number, number  _c_m_get_scale([Comp])  
nil             _c_m_set_scale([Comp], number scale_x, number scale_y)

number, number  _c_m_get_offset([Comp])  
nil             _c_m_set_offset([Comp], number offset_x, number offset_y)   
```

static_mesh component (_c_sm):  

```lua
render_config   _c_sm_get_render_config([Comp])  
nil             _c_sm_set_render_config([Comp], render_config rc)
```

sprite component (_c_s):  

```lua
integer         _c_s_get_sprite([Comp])  
nil             _c_s_set_sprite([Comp], integer new_sprite)

nil             _c_s_set_shader([Comp], string new_shader)  
```

flipbook component (_c_f):

```lua
integer         _c_f_get_animation([Comp])                                      --returns current flipbook animation hashed name   
nil             _c_f_set_animation([Comp], string/integer animation_name)       --sets animation of given name as current
  
bool            _c_f_get_looping([Comp])  
nil             _c_f_set_looping([Comp], bool looping)
```

camera component (_c_c):  

```lua
number          _c_c_get_ortho_width([Comp])    
nil             _c_c_set_ortho_width([Comp], number new_ortho)

number          _c_c_get_lowest_layer([Comp])                               --returns number of the deepest rendered layer  
nil             _c_c_set_lowest_layer([Comp], number new_lowest_layer)      --sets number of the deepest rendered layer

number          _c_c_get_highest_layer([Comp])                              --returns number of the highest rendered layer  
nil             _c_c_set_highest_layer([Comp], number new_highest_layer)    --sets number of the highest rendered layer

bool            _c_c_get_active([Comp])                                     --returns whether this camera component is currently used for rendering  
nil             _c_c_set_active([Comp])                                     --makes camera component used for rendering
```

behavior component (_c_b): 

```lua
string          _c_b_get_behavior([Comp])                               --returns currently used behavior asset  
nil             _c_b_set_behavior([Comp], string behavior_asset_path)   --assign new behavior asset to the component

nil | value     _c_b_call([Comp], string event_name, table args)        --calls function named "event\_" + event_name implemented in behavior asset. If not implemented returns nil. 
```

collider component (_c_cl): 

```lua
string          _c_cl_get_collision_preset([Comp])                          --returns collision preset used by collider  
nil             _c_cl_set_collision_preset([Comp], string new_preset_name)  --asigns new collision preset to the collider

number, number  _c_cl_get_offset([Comp])                                    --returns (x, y) offset from owner   
nil             _c_cl_set_offset([Comp], number x, number y)                --asigns new (x, y) offset from owning entity

number, number  _c_cl_get_extend([Comp])                                    --returns (x, y) collider extend   
nil             _c_cl_set_extend([Comp], number x, number y)                --asigns new (x, y) collider extend

integer         _c_cl_get_layer_offset([Comp])                              --returns collider's layer offset from owning entity layer  
nil             _c_cl_set_layer_offset([Comp], integer new_layer_offset)    --asigns layer offset
```

dynamics component (_c_d): 

```lua
nil             _c_d_add_force([Comp], number x, number y) -                                --adds (x, y) force  
nil             _c_d_add_movement_input([Comp], number dir_x, number dir_y, number speed)   --adds force in normalized (dir_x, dir_y) direction multiplied by speed

number          _c_d_get_drag([Comp])                                                       --returns movement drag  
nil             _c_d_set_drag([Comp], number new_drag)                                      --assigns new movement drag

number          _c_d_get_mass([Comp])                                                       --returns assigned mass  
nil             _c_d_set_mass([Comp], number new_mass)                                      --assigns new mass

bool            _c_d_get_use_max_vel([Comp])                                                --returns whether to limit velocity to max_velocity  
nil             _c_d_set_use_max_vel([Comp], bool use)                                      --sets whether to limit velocity to max_velocity

number          _c_d_get_max_vel([Comp])                                                    --returns max_velocity  
nil             _c_d_get_vel([Comp], number new_max_vel)                                    --assigns new max_velocity

number, number  _c_d_get_vel([Comp])                                                        --returns (x, y) velocity  
nil             _c_d_set_vel([Comp], number x, number, y)                                   --assigns new (x, y) velocity

bool            _c_d_get_gravity_enabled([Comp])                                            --returns whether the gravity force is applied on the component
nil             _c_d_set_gravity_enabled([Comp], bool enabled)                              --sets whether to apply gravity force on the component

bool            _c_d_get_grounded([Comp])                                                   --returns whether entity is currently standing on the ground. Valid only if the project is not - topdown
```  

tilemap component (_c_t):  

```lua
number          _c_t_get_layers_stride([Comp])                          --returns stride between tilemap layers  
nil             _c_t_set_layers_stride([Comp], number new_stride)       --assigns new stride between tilemap layers   
```

listener component (_c_l):

```lua
bool            _c_l_get_active([Comp])    --returns whether the sound captured by this listener will be streamed to the audio output
nil             _c_l_set_active([Comp])    --sets whether the sound captured by this listener will be streamed to the audio output   
```

sound_emmiter component (_c_se):  

```lua
nil             _c_se_emit_sound([Comp], string sound_asset_to_emmit, number volume_precent)    --emmits sound at the owner's world position, that can be captured by a listener component   
```

## Input Functions
Input functions uses _i prefix.  

```lua
bool            _i_action(string action_name)                   --returns the state of given action; true if pressed and false if not  
bool            _i_action_just_pressed(string action_name)      --returns if action was pressed in this exact frame  
bool            _i_action_just_relased(string action_name)      --returns if action was relased in this exact frame
 
number          _i_axis(string axis_name)                       --returns the state of the given axis mapping

nil             _i_set_mouse_visible(bool visible)  
```

## Collision Functions
Collision functions uses _cl prefix. 

```lua
trace_result    _cl_trace(string trace_collision_preset, number start_x, number start_y, number end_x, number end_y) --casts a trace from (start_x, start_y) to (end_x, end_y) and returns if it has hitten any collider
```
The result is a table : 
```yaml
{
   entity   : {hited entity or a nil},
   distance : {hit distance from (start_x, start_y) or a nil}
}
```

## Audio Functions
Audio functions uses _a prefix.   

```lua
nil             _a_set_volume(number new_volume_precent)                                                    --assigns new global volume

nil             _a_play_sound(string sound_asset)                                                           --simply plays given sound

nil             _a_play_sound_at_channel(string sound_asset, integer | string channel_name, bool looping)   --creates playback object i.e.channel that allows to control the sound playback, and starts to play given sound on it  
nil             _a_set_volume_at_channel(integer | string channel_name, number new_volume_precent)          --assigns additional volume modyficator to the channel  
nil             _a_resume_channel(integer | string channel_name)                                            --resumes the playback  
nil             _a_stop_channel(integer | string channel_name)                                              --stops the playback  
nil             _a_set_channel_position(integer | string channel_name, number x, number y, number layer)    --puts given channel in the position in space. After calling, the sound is affected by the audio rolloff   
```

## Engine Functions
Engine functions uses _en prefix.  

```lua
nil             _en_load_scene(integer | string scene_name, string scene_asset, number x_world_offset, number y_world_offset)   --creates a scene from the given scene_asset, and then registers it using scene_name, so other functions can refer to this exact scene instance using this name. Also offsets all entities in the new scene by (x_world_offset, y_world_offset)  
nil             _en_unload_scene(integer | string scene_name)                                                                   --unloads the scene with all the entities in it   
table           _en_get_entities_in_scene(integer | string scene_name)                                                          --returns a table containing references to all the entities in the scene

number, number  _en_viewport_to_world(number v_x, number v_y)                                                                   --translates (v_x, v_y) viewport coordinates into world coordinates 
 
table           _en_load_custom_data(string custom_data_asset)                                                                  --loads and return the content of the given custom data asset  

number          _en_time_period_to_physics(number time)                                                                         --multiplies time by physics_time_dilation modyficator and returns  
nil             _en_set_physics_time_dilation(number new_dilation)                                                              --sets global physics time dilation modyfiactor. This change affects dynamics components, but not the delta_time argument passed into the on_update functions   

nil             _en_save_data(string filename, table data)                                                                      --saves data as a filename + .json file in the saved engine directory   
bool            _en_data_exists(string filename)                                                                                --return whether a file with the given filename exists   
table           _en_load_data(string filename)                                                                                  --restores data saved using _en_save_data from the given file 

nil             _en_create_entities_from_tilemap(string tilemap_asset, func creator_function)                                   --tiled's object layers integration. For every object on any of the object layers in the tilemap, it creates entity and calls creator_function (2) with table of arguments (1), so it can process the entity further
```
 
(1) Table of arguments contains:

```yaml
{
    entity_ref entity : created entity
    string name       : tiled object name
    string class      : tiled object class
    number x, y       : world space entity position (in engine units)
    number layer      : entity's layer
    number width, height = object dimensions (in engine units; nil if object is not a box)
    
    + all additional user-definied object properties   
}
```
If the objects derives from a tiled template, the default object properties will be passed, unless the object instance overrides them    

(2) Example *creator_function*:
```lua
function creator(args)
    if args.class == "cactus" then
        cactus.make_cactus(args.entity)
    elseif args.class == "tree" then
        tree.make_tree(args.entity)
    end
end
``` 

# Building
## Dependencies  
SGE uses following libraries:   
[glm](https://github.com/g-truc/glm) - linear algebra  
[glfw](https://www.glfw.org/) - window creation and management  
[nothings/stb_image.h](https://github.com/nothings/stb/blob/master/stb_image.h) - images loading   
[nlohmann/json](https://github.com/nlohmann/json) - json files    
[miniaudio](https://miniaud.io/) - audio library  
[lua 5.4.2](https://luabinaries.sourceforge.net/download.html) - lua  

## Building the engine  
This tutorial explains how to build the engine on 64 bit windows machine.  
In order to build the engine from source you first need to clone this repo.  
From now we will refer to the repo folder as `repo/`.  
Once you have it, go to `repo/core_game` and create `include` and `libs` folders inside.  
Now we have to get required libraries. 

### GLM
To download GLM go to [https://github.com/g-truc/glm](https://github.com/g-truc/glm) and clone the repo.  
Then enter it and move `glm` folder to the `repo/core_game/include`.  

### GLFW
To download GLFW go to [https://www.glfw.org/download.html](https://www.glfw.org/download.html) and then press `64 bit Windows Binaries`.  
Once you have them, unzip and enter. Then go to `include` directory. Rename the `GLFW` folder to `glfw` and then move it to the `repo/core_game/include`.
When you have it done, go back to your glfw binaries and then move `glfw3.lib` from `lib-vc2022` to the `repo/core_game/libs` folder.

### STB_IMAGE
Inside the `repo/core_game/include` directory create a new folder named `stb`. Inside it create two files: `stb_image.h` and `stb_image.cpp`. 
Open the `stb_image.cpp` file and paste in the following code:
```
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"
```
Then go to [https://github.com/nothings/stb/blob/master/stb_image.h](https://github.com/nothings/stb/blob/master/stb_image.h), and paste it's content to into the `stb_image.h` file.

### NLOHMANN JSON
Clone [https://github.com/nlohmann/json](https://github.com/nlohmann/json) and unzip it. 
Open the repo, go into the `include` folder and then copy the `nlohmann` folder into the `repo/core_game/include` folder.

### MINIAUDIO
Inside the `repo/core_game/include` directory create a new folder named `miniaudio`. Inside it create two files: `miniaudio.h` and `miniaudio.c`. 
Open the `miniaudio.c` file and paste in the following code:
```
#define MINIAUDIO_IMPLEMENTATION
#include "miniaudio.h"
```
Then go to [https://raw.githubusercontent.com/mackron/miniaudio/master/miniaudio.h](https://raw.githubusercontent.com/mackron/miniaudio/master/miniaudio.h), and paste it's content to into the `miniaudio.h` file.  

### LUA
In the `repo/core_game/include` directory create a new named `lua_5_4_2`.  
Now go to the [https://luabinaries.sourceforge.net/download.html](https://luabinaries.sourceforge.net/download.html) site and download the `lua-5.4.2_Win64_dllw6_lib.zip`. If you are using mac or linux, take some other option, but remember that next steps will look diffrent for you then. 
Once you have your .zip, move it to the `repo/core_game/include/lua_5_4_2` and unzip.
After doing that pick `lua54.lib` and `lua54.dll` and move them to the `repo/core_game/libs` folder. 

### GRAPHICS ABSTRACTION
(TODO)

### GRAPHICS ABSTRACTION OPENGL 3.3
(TODO)

## Build
Once you have all depedencies installed, open Vs folder an launch the solution. Now we can finaly get to compiling the project.  
You can compile the engine in two configurations:  
- Debug, used for developing mods and the engine itself. In this configuration program does create a console window once launched. Also, it directly loads one specyfic mod, given in the ``debug_config.h`` file (details below). Furthermore it does not require packing the engine for shipping, as all the paths required by the engine, instead of being relative to ``main.cpp`` can be specified in ``debug_config.h``.
- Relase, as the name suggest, intended for shipping. It does not create a console window once launched. Also it does contains (but not yet) a mod selection feature. To run it requires additional program structure (details below, in *shipping the relase*)

### Debug 
In order to build in debug you need to create a ``debug_config.h`` in the ``repo/core_game`` folder (the folder containing ``main.cpp`` file).  
The ``debug_config.h`` should look like this:
```c
const std::string debug_mods_directory =			{ Absolute Path };    //Folder containing all the mods
const std::string debug_core_asssets_directory =	        { Absolute Path };    //Folder containing engine assets; repo/core_game/assets
const std::string debug_loaded_mod =				{ Absolute Path };    //Folder containing mod to be loaded; Should be a subfolder of debug_mods_directory
const std::string debug_saved_directory =			{ Absolute Path };    //An empty folder for mods to save their data
```




















